# -*- coding: utf-8 -*-
"""Wifi_Interrupt_measure.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NsJ2hJ3r6ZLja2LWSSqBDrb0LUp6Fv3Z
"""

import time, datetime
import requests
print('Done importing')

#global vars (Don't modify unless necessary):
datetimeFormat= "%d %b %y %H:%M:%S" #for datetime and time functions
days_to_seconds=24*60*60

interruptCounter=0
totalinterruptTime=0

"""###Functions:"""

#@title Helper Functions definition
#Helper functions:
def setStartEnd(startv, endv, runfor_minutes=5): #Don't put default values inside arg definition (arg=) as they are only computed once at runtime
  if(startv==endv): #if kept as default value (currTimestr)
    startTime= datetime.datetime.strptime(startv, datetimeFormat) +datetime.timedelta(seconds=5)
    endTime= datetime.datetime.strptime(endv, datetimeFormat) +datetime.timedelta(minutes=runfor_minutes, seconds=5)
  else:
    startTime= datetime.datetime.strptime(startv, datetimeFormat)
    endTime= datetime.datetime.strptime(endv, datetimeFormat)
  return startTime, endTime

def tryConnection(url):
  try:
    response=requests.get('https://google.com').status_code
    #print(response)
  except requests.exceptions.ConnectionError:
    response=0
    #print('Connection Error exception', response)
  return response #response is now a number NOT an object

def getCurrTime():
  currTimestr=time.strftime(datetimeFormat, time.localtime()) #stringifying local time according to our chosen format
  currTime_dt=datetime.datetime.strptime(currTimestr, datetimeFormat) #Converts currTime string to datetime object for comparison
  return currTime_dt
  
def intTryParse(value):
    try:
        return int(value) #, True
    except ValueError:
        return value #, False

def Delaysec(sec):
  time.sleep(sec)

def OutputFile(startTime, endTime, interruptCounter, totalinterruptTime, averageInterruptTime):
  f= open("Wifi_interrupt_results.txt","w+") #Plus sign indicates create a file if it does not exist.
  f.write("Start_Time: {0} \n" .format(startTime))
  f.write("End_Time: {0} \n" .format(endTime))
  f.write("Duration: {0} \n" .format(endTime-startTime))
  f.write("Interrupt_Counter: {0} \n" .format(interruptCounter))
  f.write("Total_interrupt_Time: {0} seconds\n" .format(totalinterruptTime))
  f.write("Average_Interrupt_Time: {0} seconds per interruption\n" .format(averageInterruptTime))
  f.close()

#Main function:
def Measure(startTime, endTime, interruptCounter, totalinterruptTime):
  averageInterruptTime=0
  url='https://google.com'
  currTime_dt = getCurrTime()

  if(currTime_dt < startTime):
    print('Measurements will start in: ', startTime-currTime_dt)
  while(currTime_dt<startTime): #in case we want to schedule the script to run later
    Delaysec(1)
    currTime_dt = getCurrTime()

  print('Measure Started at: ', currTime_dt)
  print('Duration: ', endTime-startTime) #Can be used with 'tqdm' for making a loding bar
  if(currTime_dt>=startTime): #>= in case currTime passes startTime
    while(currTime_dt < endTime):
      response = tryConnection(url) #response is now a number NOT an object
      #print(response.status_code)
      if(response!=200): #similar to if(response==0)
        print('Interruption occured')
        interruptCounter+=1
        while(response!=200):
          # if(getCurrTime()>endTime): #Avoid going over endTime (in case connection lost for too long)
          #   print('Connection was still lost until time was over')
          #   break

          response = tryConnection(url)
          if(response==200):
            print('Connection reestablished')
            continue
          totalinterruptTime+= 1 #1 since delaying 1 sec
          Delaysec(1)

      #runs every iteration while (currTime_dt < endTime)
      Delaysec(2)
      currTime_dt = getCurrTime()

    #After while breaks  
    endTime= getCurrTime()
    print('Measure Ended at: ', endTime) #runs after while loop finishes

  if(interruptCounter>0): #avoid division by 0
    averageInterruptTime = totalinterruptTime / interruptCounter
  OutputFile(startTime, endTime, interruptCounter, totalinterruptTime, averageInterruptTime)

"""###Main program running here:

<font color="red">Modify variables in cell below:</font>
"""

#Console input
runfor_minutes= input("Enter for how many MINUTES this program shoud run: ")
runfor_minutes= intTryParse(runfor_minutes)
if(type(runfor_minutes)!=int):
	while(type(runfor_minutes)!=int):
		runfor_minutes= input("Please enter a whole number: ")
		runfor_minutes= intTryParse(runfor_minutes)
		
		
#Default values:
defaultv = time.strftime(datetimeFormat, time.localtime())
# startTime = datetime.datetime.strptime("11 Mar 20 22:37:00", datetimeFormat)
# endTime = datetime.datetime.strptime("11 Mar 20 22:38:00", datetimeFormat)

#Modify Before Running:
startTime, endTime = setStartEnd(defaultv, defaultv, runfor_minutes) #Default value
print("Default: ", startTime, endTime)
print(startTime>endTime, startTime<getCurrTime())
print(getCurrTime())
# startTime, endTime = setStartEnd("11 Mar 20 22:37:00", "11 Mar 20 22:38:00") #Set values
# print(startTime, endTime)

#Run code
currTime_dt=getCurrTime()
diff_in_seconds=(endTime - startTime).seconds + (endTime - startTime).days*days_to_seconds
print('Difference in days = ', diff_in_seconds/days_to_seconds,' in seconds = ', diff_in_seconds)
 
if(startTime < currTime_dt):
  print('ERROR: (Start_Time < Current_Time) : CANNOT act from the past ')
elif(startTime > endTime):
  print('ERROR: (startTime > endTime) : CANNOT act from the past ')
elif(diff_in_seconds/days_to_seconds > 1):
  print('It is not recommended to run this script for more than 1 day')
else:
  Measure(startTime, endTime, interruptCounter, totalinterruptTime)
